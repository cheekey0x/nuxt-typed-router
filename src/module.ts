import { camelCase } from 'lodash';
import chalk from 'chalk';
import { Module } from '@nuxt/types';
import { NuxtTypedRouterOptions, RouteParamsDecl } from './types';
import { NuxtRouteConfig } from '@nuxt/types/config/router';
import { saveRoutesFiles } from './save';
import { extractMatchingSiblings, extractUnMatchingSiblings, transformRouteNames } from './utils';
import { ModuleThis } from '@nuxt/types/config/module';
import { defineNuxtModule } from '@nuxt/kit';
import { resolve } from 'path';

declare module '@nuxt/types/config/router' {
  interface NuxtRouteConfig {
    file?: string;
  }
}

const typedRouterModule: Module<NuxtTypedRouterOptions> = function (moduleOptions) {
  const {
    filePath = `${this.options.srcDir}/__routes.ts`,
    routesObjectName = 'routerPagesNames',
    stripAtFromName = false,
  }: NuxtTypedRouterOptions = { ...this.options.typedRouter, ...moduleOptions };
  this.addPlugin({
    src: resolve(__dirname, './templates/typed-router.js'),
    fileName: 'typed-router.js',
  });
  this.nuxt.hook('build:before', () =>
    routeHook.call(this, filePath, routesObjectName, stripAtFromName)
  );
  this.nuxt.hook('build:extendRoutes', () =>
    routeHook.call(this, filePath, routesObjectName, stripAtFromName)
  );
};

function routeHook(
  this: ModuleThis,
  filePath: string,
  routesObjectName: string,
  stripAtFromName: boolean
) {
  try {
    // Redirect with @
    this.extendRoutes(async (routes: NuxtRouteConfig[]) => {
      transformRouteNames(routes, stripAtFromName);

      let routesObjectString = '{';
      let routesList: string[] = [];
      let routesParams: RouteParamsDecl[] = [];
      let routeObjectJs: Record<string, any> = {};

      const recursiveTypedRoutes = (
        route: NuxtRouteConfig,
        level: number,
        routeObject: Record<string, any>,
        siblings?: NuxtRouteConfig[],
        parentName?: string
      ) => {
        console.log(route);
        const matchingSiblings = extractMatchingSiblings(route, siblings);
        const haveMatchingSiblings = !!matchingSiblings?.length && route.path !== '/';
        const chunkArray = route.file?.split('/') ?? [];
        const lastChunkArray = chunkArray[chunkArray?.length - 1].split('.vue')[0];
        const isRootSibling = lastChunkArray === 'index';
        if (
          (route.children?.length && !haveMatchingSiblings) ||
          (!route.children?.length && haveMatchingSiblings && isRootSibling)
        ) {
          let childrenChunks = haveMatchingSiblings ? matchingSiblings : route.children;
          const splittedPaths = route.path.split('/');
          const parentPath = splittedPaths[splittedPaths.length - 1];
          const nameKey = camelCase(parentPath || 'index');
          console.log(nameKey);
          routesObjectString += `${nameKey}:{`;
          routeObject[nameKey] = {};
          childrenChunks?.map((r) =>
            recursiveTypedRoutes(
              r,
              level + 1,
              routeObject[nameKey],
              extractUnMatchingSiblings(route, siblings),
              nameKey
            )
          );
          routesObjectString += '},';
        } else {
          let splitted: string[] = [];
          if (route.name) {
            splitted = route.name.split('-');
            splitted = splitted.slice(level, splitted.length);
            if (splitted[0] === parentName) {
              splitted.splice(0, 1);
            }

            const keyName = route.path === '' ? 'index' : camelCase(splitted.join('-')) || 'index';
            routesObjectString += `'${keyName}': '${route.name}',`;
            routesList.push(route.name);
            const params = route.path.match(/:(\w+)/);
            params?.shift();
            if (params?.length) {
              routesParams.push({
                name: route.name,
                params: params.map((m) => ({ key: m, type: 'string | number' })),
              });
            }
            routeObject[keyName] = route.name;
          }
        }
      };
      routes.map((r) =>
        recursiveTypedRoutes(
          r,
          0,
          routeObjectJs,
          routes?.filter((f) => f.path !== r.path)
        )
      );
      routesObjectString += '}';

      const templateRoutes = `
      /** Generated by nuxt-typed-router. Do not modify */
      export const ${routesObjectName} = ${routesObjectString};
      
      export type TypedRouteList = ${routesList.map((m) => `'${m}'`).join('|\n')}

      export type TypedRouteParams = {
        ${routesParams
          .map(
            ({ name, params }) => `"${name}": {
          ${params.map((p) => `"${p.key}"?: ${p.type}`).join(',\n')}
        }`
          )
          .join(',\n')}
      }

      `;

      await saveRoutesFiles(filePath, templateRoutes);
    });

    // Typed router
  } catch (e) {
    console.error(chalk.red('Error while generating routes definitions model'), '\n' + e);
  }
}

module.exports = typedRouterModule;
module.exports.meta = require('../package.json');
